<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>coursework on Sam Robbins</title><link>https://samrobbins.uk/categories/coursework/</link><description>Recent content in coursework on Sam Robbins</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Mon, 02 Mar 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://samrobbins.uk/categories/coursework/index.xml" rel="self" type="application/rss+xml"/><item><title>Conway's Game of Life</title><link>https://samrobbins.uk/portfolio/conway-s-game-of-life/</link><pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate><guid>https://samrobbins.uk/portfolio/conway-s-game-of-life/</guid><description>For this coursework we were to implement Conway&amp;rsquo;s Game of Life in C. This consists of a DLL and a program that calls the library for key functionality.
Dynamically Linked Library This was to implement a range of functions
read_in_file() reads in the file from the filepointer infile and stores the universe in the structure pointed to by u. You must use dynamic memory allocation. write_out_file() writes the content of the universe pointed to by u into the file from the file pointer outfile is_alive returns 1 if the cell in that column and row is alive and 0 otherwise will_be_alive() returns 1 if that cell in that column and row will be alive in the next generation and 0 otherwise, assuming that cells outside the universe are always dead will_be_alive_torus() returns 1 if the cell in that column and row will be alive in the next generation and 0 otherwise, assuming a torus topology evolve() changes the universe from the current generation to the next generation.</description></item><item><title>AI Search</title><link>https://samrobbins.uk/portfolio/ai-search/</link><pubDate>Mon, 20 Jan 2020 00:00:00 +0000</pubDate><guid>https://samrobbins.uk/portfolio/ai-search/</guid><description>For this project we were to implement two algorithms for solving the travelling salesman problem.
I decided to implement Christofides algorithm and a Greedy Algorithm.
Greedy algorithm The basic greedy algorithm selects the next node with the lowest cost. However I enhanced this as there was indecision when there were multiple minimums to choose from as it couldn&amp;rsquo;t be determined which was best.
To solve this problem, my enhanced code looked ahead at what the cost would be of choosing the different choices, and chose the one that gave the lowest cost</description></item><item><title>Bulletin Board</title><link>https://samrobbins.uk/portfolio/bulletin-board/</link><pubDate>Fri, 06 Dec 2019 00:00:00 +0000</pubDate><guid>https://samrobbins.uk/portfolio/bulletin-board/</guid><description>This coursework was to implement a client-server system for a simple anonymous bulletin board system using TCP.
This system makes heavy use of the socket Python library for communicating between the client and server. There is also a large amount of error checking involved to ensure that commands can be properly executed.
Error checking The following errors were checked for
Unavailable/busy port No message boards defined Specified board doesn&amp;rsquo;t exist Invalid message Logs The server program keeps logs of every request it receives during all client-server communication</description></item><item><title>Security Coursework</title><link>https://samrobbins.uk/portfolio/security-coursework/</link><pubDate>Fri, 06 Dec 2019 00:00:00 +0000</pubDate><guid>https://samrobbins.uk/portfolio/security-coursework/</guid><description>For this coursework we were to find vulnerabilities in a system and explain how they could be mitigated, along with solving a murder mystery in the system, which required finding and decoding a range of files.
Vulnerabilities Database file can be opened by any user There was a file in the database folder named Database.db, this could be opened using sqlite and with the command SELECT * FROM Users, you could find personal information on the users, such as passwords.</description></item><item><title>Bioinformatics</title><link>https://samrobbins.uk/portfolio/bioinformatics/</link><pubDate>Thu, 02 May 2019 23:00:00 +0000</pubDate><guid>https://samrobbins.uk/portfolio/bioinformatics/</guid><description>DNA Alignment This takes two DNA sequences and produces the optimal alignment. This is done by filling out a backtracking matrix.
This has a simple piece of driver code which loops through all the cells of the backtrack matrix
for a in range(1,len(seq1)+1): for b in range(1,len(seq2)+1): fill_cell(m,backtrack,seq1,seq2,a,b) The fill_cell function then determines the entry in the backtracking matrix and the maximum score of a matching
def fill_cell(m,backtrack,seq1,seq2,a,b): # Here m is the matrix and [b,a] is the location of the cell to fill out # Diagonal max=score(a,b,seq1,seq2)+m[b-1,a-1] pos=&amp;#39;D&amp;#39; # Up temp=m[b-1,a]-2 if temp&amp;gt;max: max=temp pos=&amp;#39;U&amp;#39; # Left temp=m[b,a-1]-2 if temp&amp;gt;max: max=temp pos=&amp;#39;L&amp;#39; m[b,a]=max backtrack[b,a]=pos return The rules for scoring were given in the assignment, and are implemented using the score function</description></item><item><title>Slate my doggo</title><link>https://samrobbins.uk/portfolio/slate-my-doggo/</link><pubDate>Wed, 01 May 2019 23:00:00 +0000</pubDate><guid>https://samrobbins.uk/portfolio/slate-my-doggo/</guid><description>This site has a simple user interface with two buttons. The show me a random doggo button will select a random image, and the associated comments. The gimme more doggos button fetches new images using the Reddit API.
API A REST API was implemented to allow for interfacing with the backend. The API was implemented with three functions
List This is a GET request which will give you the JSON of an image with the appropriate links</description></item><item><title>Modelling with Graphs</title><link>https://samrobbins.uk/portfolio/modelling-with-graphs/</link><pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate><guid>https://samrobbins.uk/portfolio/modelling-with-graphs/</guid><description>In this coursework I implemented a range of graph algorithms using Python and NetworkX.
Basic greedy colouring This can be found in the file Part A/greedy_col_basic.py
This is designed to:
Visit the vertices of the graph sequentially At every step assign in a greedy fashion the smallest possible colour Output the constructed colouring and the number of different colours in the colouring For this I implemented two functions</description></item><item><title>Error Correcting Codes</title><link>https://samrobbins.uk/portfolio/error-correcting-codes/</link><pubDate>Fri, 15 Feb 2019 00:00:00 +0000</pubDate><guid>https://samrobbins.uk/portfolio/error-correcting-codes/</guid><description>In this coursework I implemented a range of functions for different methods of error correcting codes
Hamming codes Message This function takes a vector and converted it to a message that can be used in a hamming code
def message(a): if not checkvalid(a): return [] l = len(a) r = 2 while (2 ** r - 2 * r - 1) &amp;lt; l: r += 1 k = 2 ** r - r - 1 length = list(bin(l)[2:]) length = [int(x) for x in length] length = [0] * (r - len(length)) + length end = [0] * (k - r - l) return length + a + end Hamming Encoder This acts as an encoder for hamming codes</description></item><item><title>p5 Component</title><link>https://samrobbins.uk/portfolio/p5-component/</link><pubDate>Thu, 14 Feb 2019 00:00:00 +0000</pubDate><guid>https://samrobbins.uk/portfolio/p5-component/</guid><description>In this coursework we were to take a p5 sketch from https://www.openprocessing.org/ and adapt it into a reusable component. For this I used the sketch https://www.openprocessing.org/sketch/429506. It looks like this:
Running This only needs an internet connection to request the various libraries involved, it can be ran by just opening the HTML file in your browser
Example functions Setup function setup() { createCanvas(windowWidth, windowHeight); rectMode(CENTER); textAlign(CENTER); textSize(14); colorMode(HSB); } Draw function draw() { let b = new shape(); b.</description></item><item><title>Algorithms and Data Structures</title><link>https://samrobbins.uk/portfolio/algorithms-and-data-structures/</link><pubDate>Mon, 21 Jan 2019 00:00:00 +0000</pubDate><guid>https://samrobbins.uk/portfolio/algorithms-and-data-structures/</guid><description>Hash Table The code for this algorithm can be found in Question 1/q1.py
This adds keys to a hash table of size 19 using the hash function defined by h(k)=6k+3 mod 19
In the first implementation hash_quadratic collisions are handled by probing
def hash_quadratic(d): #initialize table table = [&amp;#34;-&amp;#34;]*19 flag=0 #consider each integer k in the input for k in d: flag=0 #if k is already in the table this is a duplicate so move to next integer in the input #note this check for a duplicate is using the functionality of python rather than checking using a linear probe if k in table: continue #apply the hash function i = (6*k+3) % 19 init=i #initialize count that checks whether linear probe has considered each bucket and is now full count = 0 #while bucket is already filled while table[i] !</description></item></channel></rss>