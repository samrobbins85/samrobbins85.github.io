<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on Sam Robbins</title><link>https://samrobbins.uk/categories/python/</link><description>Recent content in python on Sam Robbins</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Sat, 01 Aug 2020 23:00:00 +0000</lastBuildDate><atom:link href="https://samrobbins.uk/categories/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Google AIY Emotion Detection</title><link>https://samrobbins.uk/portfolio/google-aiy-emotion-detection/</link><pubDate>Sat, 01 Aug 2020 23:00:00 +0000</pubDate><guid>https://samrobbins.uk/portfolio/google-aiy-emotion-detection/</guid><description>This project started with assembling the Google AIY Vision Kit, this was very enjoyable and gave me a good insight into what makes up the device.
This code is a fork of the Google example face_camera_detection.
Building on top of this example, I created a counter, which allowed me to keep track of how consistently happy or sad the face in the frame is.
if avg_joy_score(faces) &amp;gt; 0.8: if joy_counter &amp;lt; 0: joy_counter = 0 else: joy_counter += 1 if avg_joy_score(faces) &amp;lt; 0.</description></item><item><title>AI Search</title><link>https://samrobbins.uk/portfolio/ai-search/</link><pubDate>Mon, 20 Jan 2020 00:00:00 +0000</pubDate><guid>https://samrobbins.uk/portfolio/ai-search/</guid><description>For this project we were to implement two algorithms for solving the travelling salesman problem.
I decided to implement Christofides algorithm and a Greedy Algorithm.
Greedy algorithm The basic greedy algorithm selects the next node with the lowest cost. However I enhanced this as there was indecision when there were multiple minimums to choose from as it couldn&amp;rsquo;t be determined which was best.
To solve this problem, my enhanced code looked ahead at what the cost would be of choosing the different choices, and chose the one that gave the lowest cost</description></item><item><title>Bulletin Board</title><link>https://samrobbins.uk/portfolio/bulletin-board/</link><pubDate>Fri, 06 Dec 2019 00:00:00 +0000</pubDate><guid>https://samrobbins.uk/portfolio/bulletin-board/</guid><description>This coursework was to implement a client-server system for a simple anonymous bulletin board system using TCP.
This system makes heavy use of the socket Python library for communicating between the client and server. There is also a large amount of error checking involved to ensure that commands can be properly executed.
Error checking The following errors were checked for
Unavailable/busy port No message boards defined Specified board doesn&amp;rsquo;t exist Invalid message Logs The server program keeps logs of every request it receives during all client-server communication</description></item><item><title>Bioinformatics</title><link>https://samrobbins.uk/portfolio/bioinformatics/</link><pubDate>Thu, 02 May 2019 23:00:00 +0000</pubDate><guid>https://samrobbins.uk/portfolio/bioinformatics/</guid><description>DNA Alignment This takes two DNA sequences and produces the optimal alignment. This is done by filling out a backtracking matrix.
This has a simple piece of driver code which loops through all the cells of the backtrack matrix
for a in range(1,len(seq1)+1): for b in range(1,len(seq2)+1): fill_cell(m,backtrack,seq1,seq2,a,b) The fill_cell function then determines the entry in the backtracking matrix and the maximum score of a matching
def fill_cell(m,backtrack,seq1,seq2,a,b): # Here m is the matrix and [b,a] is the location of the cell to fill out # Diagonal max=score(a,b,seq1,seq2)+m[b-1,a-1] pos=&amp;#39;D&amp;#39; # Up temp=m[b-1,a]-2 if temp&amp;gt;max: max=temp pos=&amp;#39;U&amp;#39; # Left temp=m[b,a-1]-2 if temp&amp;gt;max: max=temp pos=&amp;#39;L&amp;#39; m[b,a]=max backtrack[b,a]=pos return The rules for scoring were given in the assignment, and are implemented using the score function</description></item><item><title>Modelling with Graphs</title><link>https://samrobbins.uk/portfolio/modelling-with-graphs/</link><pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate><guid>https://samrobbins.uk/portfolio/modelling-with-graphs/</guid><description>In this coursework I implemented a range of graph algorithms using Python and NetworkX.
Basic greedy colouring This can be found in the file Part A/greedy_col_basic.py
This is designed to:
Visit the vertices of the graph sequentially At every step assign in a greedy fashion the smallest possible colour Output the constructed colouring and the number of different colours in the colouring For this I implemented two functions</description></item><item><title>Error Correcting Codes</title><link>https://samrobbins.uk/portfolio/error-correcting-codes/</link><pubDate>Fri, 15 Feb 2019 00:00:00 +0000</pubDate><guid>https://samrobbins.uk/portfolio/error-correcting-codes/</guid><description>In this coursework I implemented a range of functions for different methods of error correcting codes
Hamming codes Message This function takes a vector and converted it to a message that can be used in a hamming code
def message(a): if not checkvalid(a): return [] l = len(a) r = 2 while (2 ** r - 2 * r - 1) &amp;lt; l: r += 1 k = 2 ** r - r - 1 length = list(bin(l)[2:]) length = [int(x) for x in length] length = [0] * (r - len(length)) + length end = [0] * (k - r - l) return length + a + end Hamming Encoder This acts as an encoder for hamming codes</description></item><item><title>Algorithms and Data Structures</title><link>https://samrobbins.uk/portfolio/algorithms-and-data-structures/</link><pubDate>Mon, 21 Jan 2019 00:00:00 +0000</pubDate><guid>https://samrobbins.uk/portfolio/algorithms-and-data-structures/</guid><description>Hash Table The code for this algorithm can be found in Question 1/q1.py
This adds keys to a hash table of size 19 using the hash function defined by h(k)=6k+3 mod 19
In the first implementation hash_quadratic collisions are handled by probing
def hash_quadratic(d): #initialize table table = [&amp;#34;-&amp;#34;]*19 flag=0 #consider each integer k in the input for k in d: flag=0 #if k is already in the table this is a duplicate so move to next integer in the input #note this check for a duplicate is using the functionality of python rather than checking using a linear probe if k in table: continue #apply the hash function i = (6*k+3) % 19 init=i #initialize count that checks whether linear probe has considered each bucket and is now full count = 0 #while bucket is already filled while table[i] !</description></item></channel></rss>