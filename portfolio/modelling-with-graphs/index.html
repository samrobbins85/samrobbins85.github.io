<!doctype html><style>html{height:100vh}body{min-height:100vh;display:grid;grid-template-rows:1fr auto}.footer{grid-row-start:2;grid-row-end:3}</style><html lang=en-gb><head><meta charset=utf-8><title>Sam Robbins</title><link rel=canonical href=https://samrobbins.uk/portfolio/modelling-with-graphs/><meta name=viewport content="width=device-width,initial-scale=1"><meta name=monetization content="$ilp.uphold.com/reGxiLfZfUmn"><meta name=description property="og:description" content="A set of algorithms on graphs"><meta name=image property="og:image" content="/"><meta name=author content="Sam Robbins"><meta name=generator content="Hugo 0.75.1"><link rel=stylesheet href=/css/syntax.min.css integrity media=screen><script src=https://cdn.jsdelivr.net/npm/mailgo@0.9.14/dist/mailgo.min.js defer></script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link href=/css/tailwind.min.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "8348650db5154c01999667d263b7e6e1"}'></script></head><body class=portfolio><div class=wrapper><nav class="fixed h-16 p-4 bg-white border-b border-gray-200 w-full z-20"><div class="flex divide-x-4 divide-transparent pr-6 text-lg items-center text-gray-700"><a href=/ class=font-normal>Home</a>
<a href=/about/ title=About>About</a>
<a href=/blog/ title=Blog>Blog</a>
<a class="text-gray-800 font-semibold" href=/portfolio/ title=Portfolio>Portfolio</a>
<a href=/writing/ title=Writing>Writing</a></div></nav><section class="pt-20 px-4"><div class="container mx-auto"><h1 class="text-4xl text-center font-semibold">Modelling with Graphs</h1><p class="text-center text-gray-600 text-xl">A set of algorithms on graphs</p><div class="py-4 text-gray-600"><p class=text-center><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentcolor" class="h-4 w-4 inline-block stroke-current text-gray-600"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5A2 2 0 003 7v12a2 2 0 002 2z"/></svg>Mar 08, 2019</p><p class=text-center><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentcolor" class="h-4 w-4 inline-block stroke-current text-gray-600"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3A9 9 0 113 12a9 9 0 0118 0z"/></svg>3 minutes</p></div><div class="flex justify-center gap-x-40 gap-y-4 flex-wrap"></div><hr class=my-4><h2 class="text-center text-3xl">Built with</h2><section class="py-6 px-2"><div class=container><div class="flex justify-center gap-x-10 flex-wrap gap-y-4"><div><a href=https://networkx.github.io/><img class="h-20 w-32 object-contain" src=https://res.cloudinary.com/samrobbins/image/upload/q_auto/v1593526379/networkx_logo_zuw9qa.svg alt=NetworkX loading=lazy style=cursor:pointer></a></div><div><a href=https://www.python.org/><img class="h-20 w-32 object-contain" src=https://res.cloudinary.com/samrobbins/image/upload/q_auto/v1591793276/logos/logos_python_pjlesq.svg alt=Python loading=lazy style=cursor:pointer></a></div></div></div></section><hr class=py-4></div></div></section><div class="container prose mx-auto w-screen px-4 pb-6"><p>In this coursework I implemented a range of graph algorithms using Python and NetworkX.</p><h2 id=basic-greedy-colouring>Basic greedy colouring</h2><p>This can be found in the file <code>Part A/greedy_col_basic.py</code></p><p>This is designed to:</p><ul><li>Visit the vertices of the graph sequentially</li><li>At every step assign in a greedy fashion the smallest possible colour</li><li>Output the constructed colouring and the number of different colours in the colouring</li></ul><p>For this I implemented two functions</p><p><code>find_smallest_color</code> - Given the graph and a given vertex, return the smallest colour that can be assigned</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>find_smallest_color</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=n>i</span><span class=p>):</span>
    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>G</span><span class=o>.</span><span class=n>nodes</span><span class=p>())</span>
    <span class=n>keys</span> <span class=o>=</span> <span class=n>G</span><span class=o>.</span><span class=n>adj</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
    <span class=nb>list</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=k>for</span> <span class=n>key</span> <span class=ow>in</span> <span class=n>keys</span><span class=p>:</span>
        <span class=nb>list</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>G</span><span class=o>.</span><span class=n>nodes</span><span class=p>[</span><span class=n>key</span><span class=p>][</span><span class=s1>&#39;color&#39;</span><span class=p>])</span>
    <span class=n>color</span><span class=o>=</span><span class=mi>1</span>
    <span class=k>while</span> <span class=n>color</span> <span class=ow>in</span> <span class=nb>list</span><span class=p>:</span>
        <span class=n>color</span> <span class=o>+=</span> <span class=mi>1</span>
    <span class=k>return</span> <span class=n>color</span>
</code></pre></div><p><code>greedy</code> - Actually perform the greedy algorithm</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>greedy</span><span class=p>(</span><span class=n>G</span><span class=p>):</span>
    <span class=k>global</span> <span class=n>kmax</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>G</span><span class=o>.</span><span class=n>nodes</span><span class=p>():</span>
        <span class=n>G</span><span class=o>.</span><span class=n>nodes</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=s1>&#39;color&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>find_smallest_color</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=n>i</span><span class=p>)</span>
    <span class=n>kmax</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>G</span><span class=o>.</span><span class=n>nodes</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=s1>&#39;color&#39;</span><span class=p>]</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>G</span><span class=o>.</span><span class=n>nodes</span><span class=p>)</span>

    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>G</span><span class=o>.</span><span class=n>nodes</span><span class=p>():</span>
        <span class=k>print</span><span class=p>(</span><span class=s1>&#39;vertex&#39;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=s1>&#39;: color&#39;</span><span class=p>,</span> <span class=n>G</span><span class=o>.</span><span class=n>node</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=s1>&#39;color&#39;</span><span class=p>])</span>
    <span class=k>print</span><span class=p>()</span>
    <span class=k>print</span><span class=p>(</span><span class=s1>&#39;The number of colors that Greedy computed is:&#39;</span><span class=p>,</span> <span class=n>kmax</span><span class=p>)</span>
</code></pre></div><h2 id=variation-on-greedy-colouring>Variation on Greedy Colouring</h2><p>This can be found in the file <code>Part A/greedy_col_variation.py</code></p><p>Instead of visiting the nodes sequentially, this should visit the vertices such that the next visited node is adjacent to at least one visited node. Amongst the list of adjacent vertices, the smallest should be chosen. Then the rest of the algorithm will be carried out as before.</p><p>For this the function <code>find_smallest_color</code> doesn&rsquo;t require any editing, but the function <code>greedy</code> is changed to look like this</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>greedy</span><span class=p>(</span><span class=n>G</span><span class=p>):</span>
    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>G</span><span class=o>.</span><span class=n>nodes</span><span class=p>())</span>
    <span class=k>global</span> <span class=n>kmax</span>
    <span class=k>global</span> <span class=n>visited_counter</span>
    <span class=n>G</span><span class=o>.</span><span class=n>nodes</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=s1>&#39;color&#39;</span><span class=p>]</span><span class=o>=</span><span class=mi>1</span>
    <span class=n>G</span><span class=o>.</span><span class=n>nodes</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=s1>&#39;visited&#39;</span><span class=p>]</span><span class=o>=</span><span class=s1>&#39;yes&#39;</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=nb>len</span><span class=p>(</span><span class=n>G</span><span class=p>)):</span>
        <span class=n>next_vertex</span><span class=o>=</span><span class=n>find_next_vertex</span><span class=p>(</span><span class=n>G</span><span class=p>)</span>
        <span class=n>G</span><span class=o>.</span><span class=n>nodes</span><span class=p>[</span><span class=n>next_vertex</span><span class=p>][</span><span class=s1>&#39;color&#39;</span><span class=p>]</span><span class=o>=</span><span class=n>find_smallest_color</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=n>next_vertex</span><span class=p>)</span>
        <span class=n>G</span><span class=o>.</span><span class=n>nodes</span><span class=p>[</span><span class=n>next_vertex</span><span class=p>][</span><span class=s1>&#39;visited&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=s1>&#39;yes&#39;</span>
    <span class=n>visited</span> <span class=o>=</span> <span class=n>nx</span><span class=o>.</span><span class=n>get_node_attributes</span><span class=p>(</span><span class=n>G</span><span class=p>,</span> <span class=s1>&#39;color&#39;</span><span class=p>)</span>
    <span class=n>kmax</span><span class=o>=</span><span class=p>(</span><span class=nb>max</span><span class=p>([</span><span class=n>v</span> <span class=k>for</span> <span class=n>k</span><span class=p>,</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>visited</span><span class=o>.</span><span class=n>items</span><span class=p>()]))</span>
    <span class=k>print</span><span class=p>()</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>G</span><span class=o>.</span><span class=n>nodes</span><span class=p>():</span>
        <span class=k>print</span><span class=p>(</span><span class=s1>&#39;vertex&#39;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=s1>&#39;: color&#39;</span><span class=p>,</span> <span class=n>G</span><span class=o>.</span><span class=n>node</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=s1>&#39;color&#39;</span><span class=p>])</span>
    <span class=k>print</span><span class=p>()</span>
    <span class=k>print</span><span class=p>(</span><span class=s1>&#39;The number of colors that Greedy computed is:&#39;</span><span class=p>,</span> <span class=n>kmax</span><span class=p>)</span>
    <span class=k>print</span><span class=p>()</span>
</code></pre></div><p>This also has the newly implemented function <code>find_next_vertex</code> which provides the index of the vertex to choose next</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>find_next_vertex</span><span class=p>(</span><span class=n>G</span><span class=p>):</span>
    <span class=n>visited</span> <span class=o>=</span> <span class=n>nx</span><span class=o>.</span><span class=n>get_node_attributes</span><span class=p>(</span><span class=n>G</span><span class=p>,</span> <span class=s1>&#39;visited&#39;</span><span class=p>)</span>
    <span class=n>visited</span><span class=o>=</span><span class=p>[</span><span class=n>k</span> <span class=k>for</span> <span class=n>k</span><span class=p>,</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>visited</span><span class=o>.</span><span class=n>items</span><span class=p>()</span> <span class=k>if</span> <span class=n>v</span><span class=o>==</span><span class=s2>&#34;yes&#34;</span><span class=p>]</span>
    <span class=n>adjacent</span><span class=o>=</span><span class=nb>set</span><span class=p>()</span>
    <span class=k>for</span> <span class=n>item</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
        <span class=n>adjacent</span><span class=o>=</span><span class=n>adjacent</span><span class=o>|</span><span class=p>(</span><span class=nb>set</span><span class=p>(</span><span class=n>G</span><span class=o>.</span><span class=n>neighbors</span><span class=p>(</span><span class=n>item</span><span class=p>)))</span>
    <span class=n>visited</span><span class=o>=</span><span class=nb>set</span><span class=p>()</span>
    <span class=k>for</span> <span class=n>item</span> <span class=ow>in</span> <span class=n>adjacent</span><span class=p>:</span>
        <span class=k>if</span> <span class=n>G</span><span class=o>.</span><span class=n>nodes</span><span class=p>[</span><span class=n>item</span><span class=p>][</span><span class=s1>&#39;visited&#39;</span><span class=p>]</span><span class=o>==</span><span class=s1>&#39;yes&#39;</span><span class=p>:</span>
            <span class=n>visited</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>item</span><span class=p>)</span>
    <span class=n>adjacent</span><span class=o>-=</span><span class=n>visited</span>
    <span class=k>return</span> <span class=nb>min</span><span class=p>(</span><span class=n>adjacent</span><span class=p>)</span>
</code></pre></div><h2 id=breadth-first-search>Breadth First Search</h2><p>This can be found in the file <code>Part B/breadth_first.py</code></p><p>This performs a breadth first search from a given node <code>a</code> to a given node <code>b</code></p><p>This is implemented in just one function</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>bfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>):</span>
    <span class=n>G</span><span class=o>.</span><span class=n>add_nodes_from</span><span class=p>(</span><span class=n>G</span><span class=o>.</span><span class=n>nodes</span><span class=p>(),</span> <span class=n>label</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=c1># initialization of all labels</span>
    <span class=n>G</span><span class=o>.</span><span class=n>node</span><span class=p>[</span><span class=n>a</span><span class=p>][</span><span class=s1>&#39;label&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
    <span class=n>i</span><span class=o>=</span><span class=mi>0</span>
    <span class=k>while</span> <span class=n>G</span><span class=o>.</span><span class=n>node</span><span class=p>[</span><span class=n>b</span><span class=p>][</span><span class=s1>&#39;label&#39;</span><span class=p>]</span><span class=o>==-</span><span class=mi>1</span><span class=p>:</span>
        <span class=n>vertex_list</span><span class=o>=</span><span class=p>[</span><span class=n>node</span> <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>G</span><span class=o>.</span><span class=n>nodes</span><span class=p>()</span> <span class=k>if</span> <span class=n>G</span><span class=o>.</span><span class=n>node</span><span class=p>[</span><span class=n>node</span><span class=p>][</span><span class=s1>&#39;label&#39;</span><span class=p>]</span><span class=o>==</span><span class=n>i</span><span class=p>]</span>
        <span class=k>for</span> <span class=n>u</span> <span class=ow>in</span> <span class=n>vertex_list</span><span class=p>:</span>
            <span class=n>adjacent</span><span class=o>=</span><span class=nb>list</span><span class=p>(</span><span class=n>G</span><span class=o>.</span><span class=n>adj</span><span class=p>[</span><span class=n>u</span><span class=p>])</span>
            <span class=k>for</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>adjacent</span><span class=p>:</span>
                <span class=n>G</span><span class=o>.</span><span class=n>node</span><span class=p>[</span><span class=n>v</span><span class=p>][</span><span class=s1>&#39;label&#39;</span><span class=p>]</span><span class=o>=</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span>
        <span class=n>i</span><span class=o>+=</span><span class=mi>1</span>
    <span class=k>return</span> <span class=n>G</span><span class=o>.</span><span class=n>node</span><span class=p>[</span><span class=n>b</span><span class=p>][</span><span class=s1>&#39;label&#39;</span><span class=p>]</span>
</code></pre></div><h2 id=depth-first-search>Depth first search</h2><p>This can be found in the file <code>Part B/depth_first_pair_nodes.py</code></p><p>This performs a depth first search starting from a given node <code>a</code> to a given node <code>b</code></p><p>At every step, among the neighbours of the currently visited vertex, the algorithm chooses the smallest one to continue the exploration from it.</p><p>In addition, it adds a label to each of the visited vertices with the path length</p><p>This is implemented with just one function</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>,</span><span class=n>u</span><span class=p>):</span>
    <span class=k>if</span> <span class=n>a</span><span class=o>==</span><span class=n>u</span><span class=p>:</span>
        <span class=n>G</span><span class=o>.</span><span class=n>node</span><span class=p>[</span><span class=n>u</span><span class=p>][</span><span class=s1>&#39;label&#39;</span><span class=p>]</span><span class=o>=</span><span class=mi>0</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>G</span><span class=o>.</span><span class=n>node</span><span class=p>[</span><span class=n>u</span><span class=p>][</span><span class=s1>&#39;label&#39;</span><span class=p>]</span><span class=o>=</span><span class=n>G</span><span class=o>.</span><span class=n>node</span><span class=p>[</span><span class=n>a</span><span class=p>][</span><span class=s1>&#39;label&#39;</span><span class=p>]</span><span class=o>+</span><span class=mi>1</span>
    <span class=n>G</span><span class=o>.</span><span class=n>node</span><span class=p>[</span><span class=n>u</span><span class=p>][</span><span class=s1>&#39;visited&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=s1>&#39;yes&#39;</span>
    <span class=k>print</span><span class=p>(</span><span class=n>u</span><span class=p>)</span>
    <span class=k>if</span> <span class=n>u</span><span class=o>==</span><span class=n>b</span><span class=p>:</span>
        <span class=k>return</span>
    <span class=n>sort_list</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>G</span><span class=o>.</span><span class=n>neighbors</span><span class=p>(</span><span class=n>u</span><span class=p>))</span>
    <span class=n>sort_list</span><span class=o>.</span><span class=n>sort</span><span class=p>()</span>
    <span class=k>for</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>sort_list</span><span class=p>:</span>
        <span class=k>if</span> <span class=n>G</span><span class=o>.</span><span class=n>node</span><span class=p>[</span><span class=n>v</span><span class=p>][</span><span class=s1>&#39;visited&#39;</span><span class=p>]</span> <span class=o>==</span> <span class=s1>&#39;no&#39;</span><span class=p>:</span>
            <span class=n>dfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=n>u</span><span class=p>,</span><span class=n>b</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span>
</code></pre></div><h2 id=diameter>Diameter</h2><p>The code for this can be found in the file <code>Part B/Diameter.py</code></p><p>The diameter is the greatest distance between any pair of vertices in the input graph. This is implemented with the breadth first algorithm seen before, along with an additional function</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>max_distance</span><span class=p>(</span><span class=n>G</span><span class=p>):</span>
    <span class=nb>max</span><span class=o>=</span><span class=mi>0</span>
    <span class=n>nodes</span><span class=o>=</span><span class=nb>list</span><span class=p>(</span><span class=n>G</span><span class=o>.</span><span class=n>nodes</span><span class=p>())</span>
    <span class=n>pairs</span><span class=o>=</span><span class=p>[[</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>]</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>nodes</span> <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>nodes</span><span class=p>]</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>pairs</span><span class=p>:</span>
        <span class=n>distance</span><span class=o>=</span><span class=n>bfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=n>i</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span><span class=n>i</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
        <span class=k>if</span> <span class=n>distance</span><span class=o>&gt;</span><span class=nb>max</span><span class=p>:</span>
            <span class=nb>max</span><span class=o>=</span><span class=n>distance</span>
    <span class=k>return</span> <span class=nb>max</span>

</code></pre></div></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous></div></body></html>