<!doctype html><style>html{height:100vh}body{min-height:100vh;display:grid;grid-template-rows:1fr auto}.footer{grid-row-start:2;grid-row-end:3}</style><html lang=en-gb><head><meta charset=utf-8><title>Sam Robbins</title><link rel=canonical href=https://samrobbins.uk/portfolio/ai-search/><meta name=viewport content="width=device-width,initial-scale=1"><meta name=monetization content="$ilp.uphold.com/reGxiLfZfUmn"><meta name=description property="og:description" content="Implementing Algorithms to solve the travelling salesman problem"><meta name=image property="og:image" content="/"><meta name=author content="Sam Robbins"><meta name=generator content="Hugo 0.75.1"><link rel=stylesheet href=/css/syntax.min.css integrity media=screen><script src=https://cdn.jsdelivr.net/npm/mailgo@0.9.14/dist/mailgo.min.js defer></script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link href=/css/tailwind.min.css rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "8348650db5154c01999667d263b7e6e1"}'></script></head><body class=portfolio><div class=wrapper><nav class="fixed h-16 p-4 bg-white border-b border-gray-200 w-full z-20"><div class="flex divide-x-4 divide-transparent pr-6 text-lg items-center text-gray-700"><a href=/ class=font-normal>Home</a>
<a href=/about/ title=About>About</a>
<a href=/blog/ title=Blog>Blog</a>
<a class="text-gray-800 font-semibold" href=/portfolio/ title=Portfolio>Portfolio</a>
<a href=/writing/ title=Writing>Writing</a></div></nav><section class="pt-20 px-4"><div class="container mx-auto"><h1 class="text-4xl text-center font-semibold">AI Search</h1><p class="text-center text-gray-600 text-xl">Implementing Algorithms to solve the travelling salesman problem</p><div class="py-4 text-gray-600"><p class=text-center><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentcolor" class="h-4 w-4 inline-block stroke-current text-gray-600"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5A2 2 0 003 7v12a2 2 0 002 2z"/></svg>Jan 20, 2020</p><p class=text-center><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentcolor" class="h-4 w-4 inline-block stroke-current text-gray-600"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3A9 9 0 113 12a9 9 0 0118 0z"/></svg>2 minutes</p></div><div class="flex justify-center gap-x-40 gap-y-4 flex-wrap"><div class="border border-gray-500 px-4 py-2 w-32"><a href=https://github.com/samrobbins85/SM-AI_Search-Coursework><img src=https://unpkg.com/simple-icons@v3/icons/github.svg class="inline-block h-6 w-6 mr-2"> Github</a></div></div><hr class=my-4><h2 class="text-center text-3xl">Built with</h2><section class="py-6 px-2"><div class=container><div class="flex justify-center gap-x-10 flex-wrap gap-y-4"><div><a href=https://www.python.org/><img class="h-20 w-32 object-contain" src=https://res.cloudinary.com/samrobbins/image/upload/q_auto/v1591793276/logos/logos_python_pjlesq.svg alt=Python loading=lazy style=cursor:pointer></a></div></div></div></section><hr class=py-4></div></div></section><div class="container prose mx-auto w-screen px-4 pb-6"><p>For this project we were to implement two algorithms for solving the travelling salesman problem.</p><p>I decided to implement Christofides algorithm and a Greedy Algorithm.</p><h2 id=greedy-algorithm>Greedy algorithm</h2><p>The basic greedy algorithm selects the next node with the lowest cost. However I enhanced this as there was indecision when there were multiple minimums to choose from as it couldn&rsquo;t be determined which was best.</p><p>To solve this problem, my enhanced code looked ahead at what the cost would be of choosing the different choices, and chose the one that gave the lowest cost</p><p>This was implemented using the following functions</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>test_next_step</span><span class=p>(</span><span class=n>tour2</span><span class=p>,</span><span class=n>depth</span><span class=p>):</span>
    <span class=c1># Doing the whole rest of the sequence takes waaaay too much time</span>
    <span class=c1># But also I really wanna get something cool working</span>
    <span class=c1># What about limiting the level of recursion</span>
    <span class=c1># Keep some counter</span>
    <span class=n>tour</span><span class=o>=</span><span class=n>tour2</span><span class=p>[:]</span>
    <span class=n>total_distance</span><span class=o>=</span><span class=mi>0</span>
    <span class=k>while</span> <span class=nb>len</span><span class=p>(</span><span class=n>tour</span><span class=p>)</span><span class=o>&lt;</span><span class=nb>len</span><span class=p>(</span><span class=n>distance_matrix</span><span class=p>[</span><span class=mi>0</span><span class=p>]):</span>
        <span class=n>first_node</span><span class=o>=</span><span class=n>distance_matrix</span><span class=p>[</span><span class=n>tour</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]][:]</span>
        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>tour</span><span class=p>:</span>
            <span class=n>first_node</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=n>infinity</span>
        <span class=n>minimum</span><span class=o>=</span><span class=nb>min</span><span class=p>(</span><span class=n>first_node</span><span class=p>)</span>

        <span class=n>indices</span> <span class=o>=</span> <span class=p>[</span><span class=n>i</span> <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>first_node</span><span class=p>)</span> <span class=k>if</span> <span class=n>x</span> <span class=o>==</span> <span class=n>minimum</span><span class=p>]</span>
        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>indices</span><span class=p>)</span><span class=o>&gt;</span><span class=mi>1</span> <span class=ow>and</span> <span class=n>depth</span><span class=o>&lt;</span><span class=mi>2</span><span class=p>:</span>
            <span class=n>minimum_index</span><span class=o>=</span><span class=n>index_decision</span><span class=p>(</span><span class=n>indices</span><span class=p>,</span><span class=n>tour</span><span class=p>,</span><span class=n>depth</span><span class=p>)</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>minimum_index</span><span class=o>=</span><span class=n>indices</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
        <span class=n>tour</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>minimum_index</span><span class=p>)</span>
        <span class=n>total_distance</span><span class=o>=</span><span class=n>total_distance</span><span class=o>+</span><span class=n>minimum</span>
    <span class=k>return</span> <span class=p>[</span><span class=n>total_distance</span><span class=p>,</span><span class=n>tour</span><span class=p>]</span>


<span class=k>def</span> <span class=nf>index_decision</span><span class=p>(</span><span class=n>indices</span><span class=p>,</span><span class=n>tour</span><span class=p>,</span><span class=n>depth</span><span class=p>):</span>
    <span class=n>shortest_distance</span><span class=o>=</span><span class=n>infinity</span>
    <span class=n>minimum_index</span><span class=o>=</span><span class=mi>0</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>indices</span><span class=p>:</span>
        <span class=n>new_tour</span><span class=o>=</span><span class=n>tour</span><span class=o>+</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
        <span class=c1># print(i)</span>
        <span class=n>distance</span><span class=o>=</span><span class=n>test_next_step</span><span class=p>(</span><span class=n>new_tour</span><span class=p>,</span><span class=n>depth</span><span class=o>+</span><span class=mi>1</span><span class=p>)[</span><span class=mi>0</span><span class=p>]</span>
        <span class=k>if</span> <span class=n>distance</span><span class=o>&lt;</span><span class=n>shortest_distance</span><span class=p>:</span>
            <span class=n>shortest_distance</span><span class=o>=</span><span class=n>distance</span>
            <span class=n>minimum_index</span><span class=o>=</span><span class=n>i</span>
    <span class=k>return</span> <span class=n>minimum_index</span>
</code></pre></div><p>Note the depth is considered here, this is to avoid too many levels of recursion as within one decision there are further decisions that could be made. Considering all of these would have a very large performance impact</p><h2 id=christofides-algorithm>Christofides algorithm</h2><p>Christofides algorithm works by creating a Minimum Spanning Tree of the graph, then finding a minimum weight matching of the nodes with an even number of vertices. This matching is then combined with the original minimum spanning tree to form a multigraph where every vertex has an even degree. Then a Eulerian circuit is formed from this multigraph and finally converted into a Hamiltonian circuit by skipping repeated vertices.</p><p>While all of these steps are complicated, they are much easier than the NP problem of TSP.</p><p>I performed an enhancement on this in the final step of skipping repeated vertices as there is a choice of which one to remove. I compared the impact of skipping the different ones had on the tour and chose the best one.</p><h2 id=performance>Performance</h2><p>In all but one of the hidden files tested on, my enhancement yielded a better result. In the one that didn&rsquo;t it matched the length.</p></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous></div></body></html>